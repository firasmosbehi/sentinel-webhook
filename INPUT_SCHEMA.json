{
  "title": "Sentinel Webhook",
  "type": "object",
  "schemaVersion": 1,
  "properties": {
    "target_url": {
      "title": "Target URL",
      "type": "string",
      "description": "The URL to monitor for changes.",
      "editor": "textfield"
    },
    "selector": {
      "title": "CSS selector (optional)",
      "type": "string",
      "description": "Optional CSS selector to watch only a specific part of the page (e.g. .price, #stock-count).",
      "editor": "textfield"
    },
    "targets": {
      "title": "Targets (optional)",
      "type": "array",
      "description": "Optional multi-target mode. Provide an array of targets to monitor. Each target can override selector/fields/ignore_json_paths. If provided, target_url is optional.",
      "editor": "json",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "target_url": { "type": "string" },
          "selector": { "type": "string" },
          "fields": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "name": { "type": "string" },
                    "selector": { "type": "string" },
                    "type": { "type": "string", "const": "text" }
                  },
                  "required": ["name", "selector", "type"]
                },
                {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "name": { "type": "string" },
                    "selector": { "type": "string" },
                    "type": { "type": "string", "const": "attribute" },
                    "attribute": { "type": "string" }
                  },
                  "required": ["name", "selector", "type", "attribute"]
                }
              ]
            }
          },
          "ignore_json_paths": {
            "type": "array",
            "items": { "type": "string" }
          }
        },
        "required": ["target_url"]
      }
    },
    "rendering_mode": {
      "title": "Rendering mode",
      "type": "string",
      "description": "How to fetch/render the page before extracting content.",
      "editor": "select",
      "default": "static",
      "enum": ["static", "playwright"]
    },
    "fetch_headers": {
      "title": "Fetch headers (optional)",
      "type": "object",
      "description": "Extra HTTP headers to include when fetching the target URL.",
      "editor": "json"
    },
    "proxy_configuration": {
      "title": "Proxy configuration (optional)",
      "type": "object",
      "description": "Optional proxy configuration for fetching the target URL. Example: {\"use_apify_proxy\": true, \"apify_proxy_groups\": [\"RESIDENTIAL\"], \"apify_proxy_country\": \"US\"} or {\"proxy_urls\": [\"http://user:pass@proxy:3128\"]}.",
      "editor": "json"
    },
    "target_domain_allowlist": {
      "title": "Target domain allowlist (optional)",
      "type": "array",
      "description": "If set, only these domains/patterns are allowed for target_url and redirects. Patterns support exact hostnames and wildcard subdomains like *.example.com.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "target_domain_denylist": {
      "title": "Target domain denylist (optional)",
      "type": "array",
      "description": "Domains/patterns that are always blocked for target_url and redirects (deny takes precedence over allow).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_url": {
      "title": "Webhook URL",
      "type": "string",
      "description": "Callback URL to POST change events to.",
      "editor": "textfield"
    },
    "webhook_domain_allowlist": {
      "title": "Webhook domain allowlist (optional)",
      "type": "array",
      "description": "If set, only these domains/patterns are allowed for webhook_url. Patterns support exact hostnames and wildcard subdomains like *.example.com.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_domain_denylist": {
      "title": "Webhook domain denylist (optional)",
      "type": "array",
      "description": "Domains/patterns that are always blocked for webhook_url (deny takes precedence over allow).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_headers": {
      "title": "Webhook headers (optional)",
      "type": "object",
      "description": "Extra headers to include in the webhook request.",
      "editor": "json"
    },
    "webhook_secret": {
      "title": "Webhook secret (optional)",
      "type": "string",
      "description": "If set, the payload will be signed and sent with an X-Sentinel-Signature header.",
      "editor": "textfield",
      "isSecret": true
    },
    "baseline_mode": {
      "title": "Baseline behavior",
      "type": "string",
      "description": "What to do on the first run when no previous snapshot exists.",
      "editor": "select",
      "default": "store_only",
      "enum": ["store_only", "notify"]
    },
    "state_store_name": {
      "title": "State store name",
      "type": "string",
      "description": "Key-Value Store name used to persist previous snapshots across runs.",
      "editor": "textfield",
      "default": "sentinel-state"
    },
    "dead_letter_dataset_name": {
      "title": "Dead-letter dataset name",
      "type": "string",
      "description": "Dataset name where failed webhook deliveries will be stored for later inspection/replay.",
      "editor": "textfield",
      "default": "sentinel-dead-letter"
    },
    "history_dataset_name": {
      "title": "History dataset name",
      "type": "string",
      "description": "Dataset name where change history events can be stored.",
      "editor": "textfield",
      "default": "sentinel-history"
    },
    "history_mode": {
      "title": "History mode",
      "type": "string",
      "description": "What to store in the history dataset.",
      "editor": "select",
      "default": "changes_only",
      "enum": ["none", "changes_only", "all_events"]
    },
    "timeout_secs": {
      "title": "Timeout (seconds)",
      "type": "integer",
      "description": "Legacy shared timeout applied to page fetches and webhook delivery (prefer fetch_timeout_secs / webhook_timeout_secs).",
      "default": 30,
      "minimum": 1
    },
    "max_retries": {
      "title": "Max retries",
      "type": "integer",
      "description": "Legacy shared retries (prefer fetch_max_retries / webhook_max_retries).",
      "default": 3,
      "minimum": 0
    },
    "retry_backoff_ms": {
      "title": "Retry backoff (ms)",
      "type": "integer",
      "description": "Legacy shared backoff (prefer fetch_retry_backoff_ms / webhook_retry_backoff_ms).",
      "default": 1000,
      "minimum": 0
    },
    "fetch_timeout_secs": {
      "title": "Fetch timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to fetching the target URL.",
      "default": 30,
      "minimum": 1
    },
    "fetch_connect_timeout_secs": {
      "title": "Fetch connect timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to establishing a network connection when fetching the target URL (best-effort).",
      "default": 10,
      "minimum": 1
    },
    "fetch_max_retries": {
      "title": "Fetch max retries",
      "type": "integer",
      "description": "Retries for transient fetch failures (network errors, 5xx, 429).",
      "default": 3,
      "minimum": 0
    },
    "fetch_retry_backoff_ms": {
      "title": "Fetch retry backoff (ms)",
      "type": "integer",
      "description": "Base backoff used between fetch retries (exponential).",
      "default": 1000,
      "minimum": 0
    },
    "webhook_timeout_secs": {
      "title": "Webhook timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to webhook delivery.",
      "default": 30,
      "minimum": 1
    },
    "webhook_max_retries": {
      "title": "Webhook max retries",
      "type": "integer",
      "description": "Retries for transient webhook failures (timeouts, 5xx, 429).",
      "default": 3,
      "minimum": 0
    },
    "webhook_retry_backoff_ms": {
      "title": "Webhook retry backoff (ms)",
      "type": "integer",
      "description": "Base backoff used between webhook retries (exponential).",
      "default": 1000,
      "minimum": 0
    },
    "webhook_retry_on_statuses": {
      "title": "Webhook retry status codes",
      "type": "array",
      "description": "HTTP status codes that should be retried for webhook delivery (in addition to 5xx if enabled).",
      "editor": "stringList",
      "items": { "type": "integer" },
      "default": [429]
    },
    "webhook_retry_on_5xx": {
      "title": "Retry webhook on 5xx",
      "type": "boolean",
      "description": "If enabled, webhook delivery retries on any 5xx response.",
      "default": true
    },
    "webhook_max_retry_time_secs": {
      "title": "Webhook max retry time (seconds)",
      "type": "number",
      "description": "Optional maximum total time (including backoff delays) spent retrying webhook delivery. Leave empty for no limit.",
      "editor": "textfield"
    },
    "max_redirects": {
      "title": "Max redirects",
      "type": "integer",
      "description": "Maximum number of redirects to follow when fetching the target URL.",
      "default": 5,
      "minimum": 0
    },
    "max_content_bytes": {
      "title": "Max content bytes",
      "type": "integer",
      "description": "Maximum number of bytes to download from the target response body.",
      "default": 2000000,
      "minimum": 1
    },
    "politeness_delay_ms": {
      "title": "Politeness delay (ms)",
      "type": "integer",
      "description": "Minimum delay between requests to the same hostname during this Actor run (helps avoid rate limits when monitoring multiple URLs/domains).",
      "default": 0,
      "minimum": 0
    },
    "politeness_jitter_ms": {
      "title": "Politeness jitter (ms)",
      "type": "integer",
      "description": "Optional random jitter added to politeness_delay_ms (0..politeness_jitter_ms).",
      "default": 0,
      "minimum": 0
    },
    "max_concurrency": {
      "title": "Max concurrency",
      "type": "integer",
      "description": "Maximum number of targets to process concurrently when using targets[].",
      "default": 1,
      "minimum": 1
    },
    "max_payload_bytes": {
      "title": "Max payload bytes",
      "type": "integer",
      "description": "Maximum webhook payload size in bytes. If exceeded, the old/new text values are truncated before sending.",
      "default": 250000,
      "minimum": 1024
    },
    "reset_baseline": {
      "title": "Reset baseline",
      "type": "boolean",
      "description": "Force storing a new baseline snapshot, even if one already exists.",
      "default": false
    },
    "min_text_length": {
      "title": "Min text length",
      "type": "integer",
      "description": "If extracted text is empty or shorter than this, apply on_empty_snapshot behavior.",
      "default": 0,
      "minimum": 0
    },
    "on_empty_snapshot": {
      "title": "On empty snapshot",
      "type": "string",
      "description": "Behavior when extracted text is empty/too short: error, treat_as_change, or ignore (keep previous baseline).",
      "editor": "select",
      "default": "error",
      "enum": ["error", "treat_as_change", "ignore"]
    },
    "min_change_ratio": {
      "title": "Min change ratio",
      "type": "number",
      "description": "Suppress changes smaller than this ratio (0..1). Uses a fast approximate ratio based on common prefix/suffix.",
      "default": 0,
      "minimum": 0,
      "maximum": 1
    },
    "fields": {
      "title": "Fields (optional)",
      "type": "array",
      "description": "Optional structured extraction. Each field is an object like {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"} or {\"name\": \"sku\", \"selector\": \"[data-sku]\", \"type\": \"attribute\", \"attribute\": \"data-sku\"}. If set, Sentinel snapshots and diffs the extracted fields.",
      "editor": "json",
      "items": {
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": { "type": "string" },
              "selector": { "type": "string" },
              "type": { "type": "string", "const": "text" }
            },
            "required": ["name", "selector", "type"]
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": { "type": "string" },
              "selector": { "type": "string" },
              "type": { "type": "string", "const": "attribute" },
              "attribute": { "type": "string" }
            },
            "required": ["name", "selector", "type", "attribute"]
          }
        ]
      }
    },
    "ignore_json_paths": {
      "title": "Ignore JSON paths (optional)",
      "type": "array",
      "description": "JSON Pointer paths to ignore when diffing application/json responses (e.g. /meta/timestamp).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_selectors": {
      "title": "Ignore selectors (optional)",
      "type": "array",
      "description": "CSS selectors to remove before extracting content (noise reduction).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_attributes": {
      "title": "Ignore attributes (optional)",
      "type": "array",
      "description": "HTML attributes to strip from the DOM before extracting content (noise reduction).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_regexes": {
      "title": "Ignore regexes (optional)",
      "type": "array",
      "description": "Regex patterns to scrub from extracted text (e.g. timestamps, tokens). Supports either plain patterns or /pattern/flags.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_regex_presets": {
      "title": "Ignore regex presets (optional)",
      "type": "array",
      "description": "Built-in ignore presets to scrub common dynamic values. Options: timestamps, uuids, tokens.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "redact_logs": {
      "title": "Redact logs",
      "type": "boolean",
      "description": "Redact sensitive-looking values (tokens/secrets) in logs and datasets.",
      "default": true
    },
    "debug": {
      "title": "Debug logging",
      "type": "boolean",
      "description": "Enable verbose logging.",
      "default": false
    }
  },
  "required": ["webhook_url"]
}
