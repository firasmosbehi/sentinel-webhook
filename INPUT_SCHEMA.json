{
  "title": "Sentinel Webhook",
  "type": "object",
  "schemaVersion": 1,
  "properties": {
    "mode": {
      "title": "Mode",
      "type": "string",
      "description": "Actor mode: monitor targets for changes, or replay failed webhook deliveries from the dead-letter dataset.",
      "editor": "select",
      "default": "monitor",
      "enum": ["monitor", "replay_dead_letter"]
    },
    "target_url": {
      "title": "Target URL",
      "type": "string",
      "description": "Primary URL to monitor for changes (required unless targets[] is set or mode=replay_dead_letter).",
      "editor": "textfield"
    },
    "selector": {
      "title": "CSS selector (optional)",
      "type": "string",
      "description": "Default CSS selector to watch only a specific part of the page (e.g. .price, #stock-count). Can be overridden per target in targets[].",
      "editor": "textfield"
    },
    "targets": {
      "title": "Targets (optional)",
      "type": "array",
      "description": "Optional multi-target mode. Provide an array of targets to monitor. Each target can override selector/fields/ignore_json_paths. If provided, target_url is optional.",
      "editor": "json",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "target_url": { "type": "string" },
          "selector": { "type": "string" },
          "fields": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "name": { "type": "string" },
                    "selector": { "type": "string" },
                    "type": { "type": "string", "const": "text" }
                  },
                  "required": ["name", "selector", "type"]
                },
                {
                  "type": "object",
                  "additionalProperties": false,
                  "properties": {
                    "name": { "type": "string" },
                    "selector": { "type": "string" },
                    "type": { "type": "string", "const": "attribute" },
                    "attribute": { "type": "string" }
                  },
                  "required": ["name", "selector", "type", "attribute"]
                }
              ]
            }
          },
          "ignore_json_paths": {
            "type": "array",
            "items": { "type": "string" }
          }
        },
        "required": ["target_url"]
      }
    },
    "rendering_mode": {
      "title": "Rendering mode",
      "type": "string",
      "description": "How to fetch/render the page before extracting content.",
      "editor": "select",
      "default": "static",
      "enum": ["static", "playwright"]
    },
    "wait_until": {
      "title": "Wait until (Playwright)",
      "type": "string",
      "description": "Playwright navigation waitUntil strategy used when rendering_mode=playwright.",
      "editor": "select",
      "default": "domcontentloaded",
      "enum": ["domcontentloaded", "load", "networkidle"]
    },
    "wait_for_selector": {
      "title": "Wait for selector (Playwright, optional)",
      "type": "string",
      "description": "Optional selector to wait for before extracting content (only used when rendering_mode=playwright). If omitted, Sentinel will use selector (when set).",
      "editor": "textfield"
    },
    "wait_for_selector_timeout_secs": {
      "title": "Wait for selector timeout (seconds)",
      "type": "integer",
      "description": "Timeout for wait_for_selector (only used when rendering_mode=playwright).",
      "default": 10,
      "minimum": 1
    },
    "playwright_block_resources": {
      "title": "Block resources (Playwright)",
      "type": "boolean",
      "description": "If enabled, abort loading images/media/fonts in Playwright mode (faster + cheaper).",
      "default": false
    },
    "screenshot_on_change": {
      "title": "Screenshot on change (Playwright)",
      "type": "boolean",
      "description": "If enabled, capture before/after screenshots when a change is detected and include artifact references in the webhook payload (Playwright only).",
      "default": false
    },
    "screenshot_scope": {
      "title": "Screenshot scope",
      "type": "string",
      "description": "Capture full page or a specific selector region (Playwright only).",
      "editor": "select",
      "default": "full_page",
      "enum": ["full_page", "selector"]
    },
    "screenshot_selector": {
      "title": "Screenshot selector (optional)",
      "type": "string",
      "description": "Selector used when screenshot_scope=selector. If omitted, uses selector.",
      "editor": "textfield"
    },
    "fetch_headers": {
      "title": "Fetch headers (optional)",
      "type": "object",
      "description": "Extra HTTP headers to include when fetching the target URL.",
      "editor": "json"
    },
    "target_method": {
      "title": "Target method",
      "type": "string",
      "description": "HTTP method used to fetch the target URL (static mode supports GET/POST/etc; Playwright currently supports GET only).",
      "editor": "textfield",
      "default": "GET"
    },
    "target_body": {
      "title": "Target body (optional)",
      "type": "string",
      "description": "Optional request body for the target request (static mode only; not allowed for GET/HEAD).",
      "editor": "textarea"
    },
    "target_cookies": {
      "title": "Target cookies (optional)",
      "type": "array",
      "description": "Optional cookies to send when fetching the target. Each item supports: name, value, domain?, path?, expires?, httpOnly?, secure?, sameSite?.",
      "editor": "json",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "name": { "type": "string" },
          "value": { "type": "string" },
          "domain": { "type": "string" },
          "path": { "type": "string" },
          "expires": { "type": "number" },
          "httpOnly": { "type": "boolean" },
          "secure": { "type": "boolean" },
          "sameSite": { "type": "string", "enum": ["Strict", "Lax", "None"] }
        },
        "required": ["name", "value"]
      }
    },
    "robots_txt_mode": {
      "title": "Robots.txt mode",
      "type": "string",
      "description": "If respect, Sentinel will try to honor robots.txt disallow rules (best-effort).",
      "editor": "select",
      "default": "ignore",
      "enum": ["ignore", "respect"]
    },
    "block_page_regexes": {
      "title": "Block page regexes (optional)",
      "type": "array",
      "description": "If any pattern matches extracted text/HTML, treat as fetch failure (prevents poisoning the baseline on soft-ban pages).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "proxy_configuration": {
      "title": "Proxy configuration (optional)",
      "type": "object",
      "description": "Optional proxy configuration for fetching the target URL. Example: {\"use_apify_proxy\": true, \"apify_proxy_groups\": [\"RESIDENTIAL\"], \"apify_proxy_country\": \"US\"} or {\"proxy_urls\": [\"http://user:pass@proxy:3128\"]}.",
      "editor": "json"
    },
    "target_domain_allowlist": {
      "title": "Target domain allowlist (optional)",
      "type": "array",
      "description": "If set, only these domains/patterns are allowed for target_url and redirects. Patterns support exact hostnames and wildcard subdomains like *.example.com.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "target_domain_denylist": {
      "title": "Target domain denylist (optional)",
      "type": "array",
      "description": "Domains/patterns that are always blocked for target_url and redirects (deny takes precedence over allow).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_url": {
      "title": "Webhook URL",
      "type": "string",
      "description": "Primary callback URL to POST events to (backwards compatible). If webhook_urls[] is set, webhook_url is treated as the first entry.",
      "editor": "textfield"
    },
    "webhook_urls": {
      "title": "Webhook URLs (optional)",
      "type": "array",
      "description": "Optional list of webhook endpoints to deliver to (fan-out). If set, Sentinel will POST the same payload to each URL.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_delivery_mode": {
      "title": "Webhook delivery mode",
      "type": "string",
      "description": "When multiple webhook_urls are configured: all = fail if any endpoint fails; any = succeed if at least one endpoint succeeds.",
      "editor": "select",
      "default": "all",
      "enum": ["all", "any"]
    },
    "webhook_method": {
      "title": "Webhook method",
      "type": "string",
      "description": "HTTP method used to deliver the webhook payload.",
      "editor": "textfield",
      "default": "POST"
    },
    "webhook_content_type": {
      "title": "Webhook content-type",
      "type": "string",
      "description": "Content-Type header for webhook requests (unless overridden in webhook_headers).",
      "editor": "textfield",
      "default": "application/json; charset=utf-8"
    },
    "webhook_domain_allowlist": {
      "title": "Webhook domain allowlist (optional)",
      "type": "array",
      "description": "If set, only these domains/patterns are allowed for webhook_url. Patterns support exact hostnames and wildcard subdomains like *.example.com.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_domain_denylist": {
      "title": "Webhook domain denylist (optional)",
      "type": "array",
      "description": "Domains/patterns that are always blocked for webhook_url (deny takes precedence over allow).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "webhook_headers": {
      "title": "Webhook headers (optional)",
      "type": "object",
      "description": "Extra headers to include in the webhook request.",
      "editor": "json"
    },
    "webhook_secret": {
      "title": "Webhook secret (optional)",
      "type": "string",
      "description": "If set, the payload will be signed and sent with an X-Sentinel-Signature header.",
      "editor": "textfield",
      "isSecret": true
    },
    "baseline_mode": {
      "title": "Baseline behavior",
      "type": "string",
      "description": "What to do on the first run when no previous snapshot exists.",
      "editor": "select",
      "default": "store_only",
      "enum": ["store_only", "notify"]
    },
    "state_store_name": {
      "title": "State store name",
      "type": "string",
      "description": "Key-Value Store name used to persist previous snapshots across runs.",
      "editor": "textfield",
      "default": "sentinel-state"
    },
    "compress_snapshots": {
      "title": "Compress snapshots",
      "type": "boolean",
      "description": "If enabled, store baseline snapshots gzipped+base64 in the state KV to reduce size.",
      "default": false
    },
    "snapshot_history_limit": {
      "title": "Snapshot history limit",
      "type": "integer",
      "description": "Keep last N snapshot metadata entries per target in the state KV (0 disables).",
      "default": 0,
      "minimum": 0
    },
    "dead_letter_dataset_name": {
      "title": "Dead-letter dataset name",
      "type": "string",
      "description": "Dataset name where failed webhook deliveries will be stored for later inspection/replay.",
      "editor": "textfield",
      "default": "sentinel-dead-letter"
    },
    "replay_limit": {
      "title": "Replay limit",
      "type": "integer",
      "description": "Maximum number of dead-letter items to replay when mode=replay_dead_letter.",
      "default": 100,
      "minimum": 1
    },
    "replay_use_stored_webhook_url": {
      "title": "Replay: use stored webhook_url",
      "type": "boolean",
      "description": "If enabled, replay uses the webhook_url stored in each dead-letter item. If disabled, replay sends all items to the current webhook_url input.",
      "default": true
    },
    "replay_dry_run": {
      "title": "Replay: dry run",
      "type": "boolean",
      "description": "If enabled, do not POST webhooks; only emit replay events to the run dataset.",
      "default": false
    },
    "history_dataset_name": {
      "title": "History dataset name",
      "type": "string",
      "description": "Dataset name where change history events can be stored.",
      "editor": "textfield",
      "default": "sentinel-history"
    },
    "history_mode": {
      "title": "History mode",
      "type": "string",
      "description": "What to store in the history dataset.",
      "editor": "select",
      "default": "changes_only",
      "enum": ["none", "changes_only", "all_events"]
    },
    "artifact_store_name": {
      "title": "Artifact store name",
      "type": "string",
      "description": "Key-Value Store name used for storing artifacts (screenshots, debug snapshots).",
      "editor": "textfield",
      "default": "sentinel-artifacts"
    },
    "store_debug_artifacts": {
      "title": "Store debug artifacts",
      "type": "boolean",
      "description": "If enabled, store previous/current snapshot JSON artifacts and include references in the webhook payload (redacted when redact_logs=true).",
      "default": false
    },
    "timeout_secs": {
      "title": "Timeout (seconds)",
      "type": "integer",
      "description": "Legacy shared timeout applied to page fetches and webhook delivery (prefer fetch_timeout_secs / webhook_timeout_secs).",
      "default": 30,
      "minimum": 1
    },
    "max_retries": {
      "title": "Max retries",
      "type": "integer",
      "description": "Legacy shared retries (prefer fetch_max_retries / webhook_max_retries).",
      "default": 3,
      "minimum": 0
    },
    "retry_backoff_ms": {
      "title": "Retry backoff (ms)",
      "type": "integer",
      "description": "Legacy shared backoff (prefer fetch_retry_backoff_ms / webhook_retry_backoff_ms).",
      "default": 1000,
      "minimum": 0
    },
    "fetch_timeout_secs": {
      "title": "Fetch timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to fetching the target URL.",
      "default": 30,
      "minimum": 1
    },
    "fetch_connect_timeout_secs": {
      "title": "Fetch connect timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to establishing a network connection when fetching the target URL (best-effort).",
      "default": 10,
      "minimum": 1
    },
    "fetch_max_retries": {
      "title": "Fetch max retries",
      "type": "integer",
      "description": "Retries for transient fetch failures (network errors, 5xx, 429).",
      "default": 3,
      "minimum": 0
    },
    "fetch_retry_backoff_ms": {
      "title": "Fetch retry backoff (ms)",
      "type": "integer",
      "description": "Base backoff used between fetch retries (exponential).",
      "default": 1000,
      "minimum": 0
    },
    "webhook_timeout_secs": {
      "title": "Webhook timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to webhook delivery.",
      "default": 30,
      "minimum": 1
    },
    "webhook_max_retries": {
      "title": "Webhook max retries",
      "type": "integer",
      "description": "Retries for transient webhook failures (timeouts, 5xx, 429).",
      "default": 3,
      "minimum": 0
    },
    "webhook_retry_backoff_ms": {
      "title": "Webhook retry backoff (ms)",
      "type": "integer",
      "description": "Base backoff used between webhook retries (exponential).",
      "default": 1000,
      "minimum": 0
    },
    "webhook_retry_on_statuses": {
      "title": "Webhook retry status codes",
      "type": "array",
      "description": "HTTP status codes that should be retried for webhook delivery (in addition to 5xx if enabled).",
      "editor": "stringList",
      "items": { "type": "integer" },
      "default": [429]
    },
    "webhook_retry_on_5xx": {
      "title": "Retry webhook on 5xx",
      "type": "boolean",
      "description": "If enabled, webhook delivery retries on any 5xx response.",
      "default": true
    },
    "webhook_max_retry_time_secs": {
      "title": "Webhook max retry time (seconds)",
      "type": "number",
      "description": "Optional maximum total time (including backoff delays) spent retrying webhook delivery. Leave empty for no limit.",
      "editor": "textfield"
    },
    "notify_on_no_change": {
      "title": "Notify on no change",
      "type": "boolean",
      "description": "If enabled, send a NO_CHANGE webhook even when there is no change (heartbeat).",
      "default": false
    },
    "notify_on_fetch_failure": {
      "title": "Notify on fetch failure",
      "type": "boolean",
      "description": "If enabled, send a FETCH_FAILED webhook on fetch errors (debounced).",
      "default": false
    },
    "fetch_failure_debounce_secs": {
      "title": "Fetch failure debounce (seconds)",
      "type": "integer",
      "description": "Debounce window for repeated fetch-failure notifications for the same target.",
      "default": 3600,
      "minimum": 0
    },
    "webhook_circuit_breaker_enabled": {
      "title": "Webhook circuit breaker",
      "type": "boolean",
      "description": "If enabled, pause webhook deliveries after repeated failures for a cooldown window.",
      "default": false
    },
    "webhook_circuit_failure_threshold": {
      "title": "Circuit breaker failure threshold",
      "type": "integer",
      "description": "Consecutive failures required to open the circuit.",
      "default": 5,
      "minimum": 1
    },
    "webhook_circuit_cooldown_secs": {
      "title": "Circuit breaker cooldown (seconds)",
      "type": "integer",
      "description": "How long to keep the circuit open after tripping.",
      "default": 3600,
      "minimum": 0
    },
    "max_redirects": {
      "title": "Max redirects",
      "type": "integer",
      "description": "Maximum number of redirects to follow when fetching the target URL.",
      "default": 5,
      "minimum": 0
    },
    "max_content_bytes": {
      "title": "Max content bytes",
      "type": "integer",
      "description": "Maximum number of bytes to download from the target response body.",
      "default": 2000000,
      "minimum": 1
    },
    "politeness_delay_ms": {
      "title": "Politeness delay (ms)",
      "type": "integer",
      "description": "Minimum delay between requests to the same hostname during this Actor run (helps avoid rate limits when monitoring multiple URLs/domains).",
      "default": 0,
      "minimum": 0
    },
    "politeness_jitter_ms": {
      "title": "Politeness jitter (ms)",
      "type": "integer",
      "description": "Optional random jitter added to politeness_delay_ms (0..politeness_jitter_ms).",
      "default": 0,
      "minimum": 0
    },
    "schedule_jitter_ms": {
      "title": "Schedule jitter (ms)",
      "type": "integer",
      "description": "Sleep a random 0..N ms at the start of the run to avoid thundering herd effects.",
      "default": 0,
      "minimum": 0
    },
    "max_concurrency": {
      "title": "Max concurrency",
      "type": "integer",
      "description": "Maximum number of targets to process concurrently when using targets[].",
      "default": 1,
      "minimum": 1
    },
    "max_payload_bytes": {
      "title": "Max payload bytes",
      "type": "integer",
      "description": "Maximum webhook payload size in bytes. If exceeded, the old/new text values are truncated before sending.",
      "default": 250000,
      "minimum": 1024
    },
    "reset_baseline": {
      "title": "Reset baseline",
      "type": "boolean",
      "description": "Force storing a new baseline snapshot, even if one already exists.",
      "default": false
    },
    "min_text_length": {
      "title": "Min text length",
      "type": "integer",
      "description": "If extracted text is empty or shorter than this, apply on_empty_snapshot behavior.",
      "default": 0,
      "minimum": 0
    },
    "on_empty_snapshot": {
      "title": "On empty snapshot",
      "type": "string",
      "description": "Behavior when extracted text is empty/too short: error, treat_as_change, or ignore (keep previous baseline).",
      "editor": "select",
      "default": "error",
      "enum": ["error", "treat_as_change", "ignore"]
    },
    "min_change_ratio": {
      "title": "Min change ratio",
      "type": "number",
      "description": "Suppress changes smaller than this ratio (0..1). Uses a fast approximate ratio based on common prefix/suffix.",
      "default": 0,
      "minimum": 0,
      "maximum": 1
    },
    "include_unified_diff": {
      "title": "Include unified diff patch",
      "type": "boolean",
      "description": "If enabled, include changes.text.patch (unified diff) in change payloads.",
      "default": false
    },
    "unified_diff_context_lines": {
      "title": "Unified diff context lines",
      "type": "integer",
      "description": "Context lines in the unified diff.",
      "default": 3,
      "minimum": 0
    },
    "unified_diff_max_chars": {
      "title": "Unified diff max chars",
      "type": "integer",
      "description": "Maximum patch length; longer diffs are truncated.",
      "default": 20000,
      "minimum": 0
    },
    "selector_aggregation_mode": {
      "title": "Selector aggregation mode",
      "type": "string",
      "description": "When selector matches multiple nodes: first = snapshot only first match; all = snapshot concatenation.",
      "editor": "select",
      "default": "all",
      "enum": ["first", "all"]
    },
    "whitespace_mode": {
      "title": "Whitespace mode",
      "type": "string",
      "description": "Whitespace normalization strategy.",
      "editor": "select",
      "default": "collapse",
      "enum": ["collapse", "preserve_lines"]
    },
    "unicode_normalization": {
      "title": "Unicode normalization",
      "type": "string",
      "description": "Optional Unicode normalization (NFKC) for more stable comparisons.",
      "editor": "select",
      "default": "none",
      "enum": ["none", "NFKC"]
    },
    "fields": {
      "title": "Fields (optional)",
      "type": "array",
      "description": "Optional structured extraction. Each field is an object like {\"name\": \"price\", \"selector\": \".price\", \"type\": \"text\"} or {\"name\": \"sku\", \"selector\": \"[data-sku]\", \"type\": \"attribute\", \"attribute\": \"data-sku\"}. If set, Sentinel snapshots and diffs the extracted fields.",
      "editor": "json",
      "items": {
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": { "type": "string" },
              "selector": { "type": "string" },
              "type": { "type": "string", "const": "text" }
            },
            "required": ["name", "selector", "type"]
          },
          {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "name": { "type": "string" },
              "selector": { "type": "string" },
              "type": { "type": "string", "const": "attribute" },
              "attribute": { "type": "string" }
            },
            "required": ["name", "selector", "type", "attribute"]
          }
        ]
      }
    },
    "ignore_json_paths": {
      "title": "Ignore JSON paths (optional)",
      "type": "array",
      "description": "JSON Pointer paths to ignore when diffing application/json responses (e.g. /meta/timestamp).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_selectors": {
      "title": "Ignore selectors (optional)",
      "type": "array",
      "description": "CSS selectors to remove before extracting content (noise reduction).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_attributes": {
      "title": "Ignore attributes (optional)",
      "type": "array",
      "description": "HTML attributes to strip from the DOM before extracting content (noise reduction).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_regexes": {
      "title": "Ignore regexes (optional)",
      "type": "array",
      "description": "Regex patterns to scrub from extracted text (e.g. timestamps, tokens). Supports either plain patterns or /pattern/flags.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_regex_presets": {
      "title": "Ignore regex presets (optional)",
      "type": "array",
      "description": "Built-in ignore presets to scrub common dynamic values. Options: timestamps, uuids, tokens.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "allow_localhost": {
      "title": "Allow localhost (local dev only)",
      "type": "boolean",
      "description": "Allow target_url/webhook_url to be localhost/loopback only in local development (blocked on Apify platform).",
      "default": false
    },
    "structured_logs": {
      "title": "Structured JSON logs",
      "type": "boolean",
      "description": "Emit one-line JSON log events to stdout.",
      "default": false
    },
    "redact_logs": {
      "title": "Redact logs",
      "type": "boolean",
      "description": "Redact sensitive-looking values (tokens/secrets) in logs and datasets.",
      "default": true
    },
    "debug": {
      "title": "Debug logging",
      "type": "boolean",
      "description": "Enable verbose logging.",
      "default": false
    }
  },
  "sections": [
    {
      "title": "Basic",
      "properties": ["mode", "target_url", "targets", "selector", "webhook_url", "webhook_urls", "baseline_mode"]
    },
    {
      "title": "Rendering",
      "properties": [
        "rendering_mode",
        "wait_until",
        "wait_for_selector",
        "wait_for_selector_timeout_secs",
        "playwright_block_resources",
        "screenshot_on_change",
        "screenshot_scope",
        "screenshot_selector"
      ]
    },
    {
      "title": "Diffing",
      "properties": [
        "selector_aggregation_mode",
        "whitespace_mode",
        "unicode_normalization",
        "fields",
        "ignore_json_paths",
        "ignore_selectors",
        "ignore_attributes",
        "ignore_regex_presets",
        "ignore_regexes",
        "min_change_ratio",
        "include_unified_diff",
        "unified_diff_context_lines",
        "unified_diff_max_chars"
      ]
    },
    {
      "title": "Fetching",
      "properties": [
        "fetch_headers",
        "target_method",
        "target_body",
        "target_cookies",
        "robots_txt_mode",
        "block_page_regexes",
        "proxy_configuration",
        "fetch_timeout_secs",
        "fetch_connect_timeout_secs",
        "fetch_max_retries",
        "fetch_retry_backoff_ms",
        "max_redirects",
        "max_content_bytes",
        "politeness_delay_ms",
        "politeness_jitter_ms",
        "schedule_jitter_ms"
      ]
    },
    {
      "title": "Webhook",
      "properties": [
        "webhook_delivery_mode",
        "webhook_method",
        "webhook_content_type",
        "webhook_headers",
        "webhook_secret",
        "webhook_timeout_secs",
        "webhook_max_retries",
        "webhook_retry_backoff_ms",
        "webhook_retry_on_statuses",
        "webhook_retry_on_5xx",
        "webhook_max_retry_time_secs",
        "notify_on_no_change",
        "notify_on_fetch_failure",
        "fetch_failure_debounce_secs",
        "webhook_circuit_breaker_enabled",
        "webhook_circuit_failure_threshold",
        "webhook_circuit_cooldown_secs",
        "max_payload_bytes"
      ]
    },
    {
      "title": "Storage",
      "properties": [
        "state_store_name",
        "compress_snapshots",
        "snapshot_history_limit",
        "artifact_store_name",
        "store_debug_artifacts",
        "dead_letter_dataset_name",
        "history_dataset_name",
        "history_mode",
        "reset_baseline"
      ]
    },
    {
      "title": "Dead-Letter Replay",
      "properties": ["replay_limit", "replay_use_stored_webhook_url", "replay_dry_run"]
    },
    {
      "title": "Security",
      "properties": [
        "target_domain_allowlist",
        "target_domain_denylist",
        "webhook_domain_allowlist",
        "webhook_domain_denylist",
        "allow_localhost",
        "redact_logs"
      ]
    },
    {
      "title": "Advanced",
      "properties": [
        "max_concurrency",
        "min_text_length",
        "on_empty_snapshot",
        "structured_logs",
        "timeout_secs",
        "max_retries",
        "retry_backoff_ms",
        "debug"
      ]
    }
  ],
  "required": ["webhook_url"]
}
