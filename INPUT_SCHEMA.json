{
  "title": "Sentinel Webhook",
  "type": "object",
  "schemaVersion": 1,
  "properties": {
    "target_url": {
      "title": "Target URL",
      "type": "string",
      "description": "The URL to monitor for changes.",
      "editor": "textfield"
    },
    "selector": {
      "title": "CSS selector (optional)",
      "type": "string",
      "description": "Optional CSS selector to watch only a specific part of the page (e.g. .price, #stock-count).",
      "editor": "textfield"
    },
    "webhook_url": {
      "title": "Webhook URL",
      "type": "string",
      "description": "Callback URL to POST change events to.",
      "editor": "textfield"
    },
    "webhook_headers": {
      "title": "Webhook headers (optional)",
      "type": "object",
      "description": "Extra headers to include in the webhook request.",
      "editor": "json"
    },
    "webhook_secret": {
      "title": "Webhook secret (optional)",
      "type": "string",
      "description": "If set, the payload will be signed and sent with an X-Sentinel-Signature header.",
      "editor": "textfield",
      "isSecret": true
    },
    "baseline_mode": {
      "title": "Baseline behavior",
      "type": "string",
      "description": "What to do on the first run when no previous snapshot exists.",
      "editor": "select",
      "default": "store_only",
      "enum": ["store_only", "notify"]
    },
    "state_store_name": {
      "title": "State store name",
      "type": "string",
      "description": "Key-Value Store name used to persist previous snapshots across runs.",
      "editor": "textfield",
      "default": "sentinel-state"
    },
    "dead_letter_dataset_name": {
      "title": "Dead-letter dataset name",
      "type": "string",
      "description": "Dataset name where failed webhook deliveries will be stored for later inspection/replay.",
      "editor": "textfield",
      "default": "sentinel-dead-letter"
    },
    "history_dataset_name": {
      "title": "History dataset name",
      "type": "string",
      "description": "Dataset name where change history events can be stored.",
      "editor": "textfield",
      "default": "sentinel-history"
    },
    "history_mode": {
      "title": "History mode",
      "type": "string",
      "description": "What to store in the history dataset.",
      "editor": "select",
      "default": "changes_only",
      "enum": ["none", "changes_only", "all_events"]
    },
    "timeout_secs": {
      "title": "Timeout (seconds)",
      "type": "integer",
      "description": "Legacy shared timeout applied to page fetches and webhook delivery (prefer fetch_timeout_secs / webhook_timeout_secs).",
      "default": 30,
      "minimum": 1
    },
    "max_retries": {
      "title": "Max retries",
      "type": "integer",
      "description": "Legacy shared retries (prefer fetch_max_retries / webhook_max_retries).",
      "default": 3,
      "minimum": 0
    },
    "retry_backoff_ms": {
      "title": "Retry backoff (ms)",
      "type": "integer",
      "description": "Legacy shared backoff (prefer fetch_retry_backoff_ms / webhook_retry_backoff_ms).",
      "default": 1000,
      "minimum": 0
    },
    "fetch_timeout_secs": {
      "title": "Fetch timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to fetching the target URL.",
      "default": 30,
      "minimum": 1
    },
    "fetch_max_retries": {
      "title": "Fetch max retries",
      "type": "integer",
      "description": "Retries for transient fetch failures (network errors, 5xx, 429).",
      "default": 3,
      "minimum": 0
    },
    "fetch_retry_backoff_ms": {
      "title": "Fetch retry backoff (ms)",
      "type": "integer",
      "description": "Base backoff used between fetch retries (exponential).",
      "default": 1000,
      "minimum": 0
    },
    "webhook_timeout_secs": {
      "title": "Webhook timeout (seconds)",
      "type": "integer",
      "description": "Timeout applied to webhook delivery.",
      "default": 30,
      "minimum": 1
    },
    "webhook_max_retries": {
      "title": "Webhook max retries",
      "type": "integer",
      "description": "Retries for transient webhook failures (timeouts, 5xx, 429).",
      "default": 3,
      "minimum": 0
    },
    "webhook_retry_backoff_ms": {
      "title": "Webhook retry backoff (ms)",
      "type": "integer",
      "description": "Base backoff used between webhook retries (exponential).",
      "default": 1000,
      "minimum": 0
    },
    "webhook_retry_on_statuses": {
      "title": "Webhook retry status codes",
      "type": "array",
      "description": "HTTP status codes that should be retried for webhook delivery (in addition to 5xx if enabled).",
      "editor": "stringList",
      "items": { "type": "integer" },
      "default": [429]
    },
    "webhook_retry_on_5xx": {
      "title": "Retry webhook on 5xx",
      "type": "boolean",
      "description": "If enabled, webhook delivery retries on any 5xx response.",
      "default": true
    },
    "webhook_max_retry_time_secs": {
      "title": "Webhook max retry time (seconds)",
      "type": "number",
      "description": "Optional maximum total time (including backoff delays) spent retrying webhook delivery. Leave empty for no limit.",
      "editor": "textfield"
    },
    "max_redirects": {
      "title": "Max redirects",
      "type": "integer",
      "description": "Maximum number of redirects to follow when fetching the target URL.",
      "default": 5,
      "minimum": 0
    },
    "max_content_bytes": {
      "title": "Max content bytes",
      "type": "integer",
      "description": "Maximum number of bytes to download from the target response body.",
      "default": 2000000,
      "minimum": 1
    },
    "max_payload_bytes": {
      "title": "Max payload bytes",
      "type": "integer",
      "description": "Maximum webhook payload size in bytes. If exceeded, the old/new text values are truncated before sending.",
      "default": 250000,
      "minimum": 1024
    },
    "reset_baseline": {
      "title": "Reset baseline",
      "type": "boolean",
      "description": "Force storing a new baseline snapshot, even if one already exists.",
      "default": false
    },
    "ignore_selectors": {
      "title": "Ignore selectors (optional)",
      "type": "array",
      "description": "CSS selectors to remove before extracting content (noise reduction).",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "ignore_regexes": {
      "title": "Ignore regexes (optional)",
      "type": "array",
      "description": "Regex patterns to scrub from extracted text (e.g. timestamps, tokens). Supports either plain patterns or /pattern/flags.",
      "editor": "stringList",
      "items": { "type": "string" }
    },
    "redact_logs": {
      "title": "Redact logs",
      "type": "boolean",
      "description": "Redact sensitive-looking values (tokens/secrets) in logs and datasets.",
      "default": true
    },
    "debug": {
      "title": "Debug logging",
      "type": "boolean",
      "description": "Enable verbose logging.",
      "default": false
    }
  },
  "required": ["target_url", "webhook_url"]
}
